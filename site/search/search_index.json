{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sommelier DB Open source DB with public-key searchable encryption: discerning encrypted data without knowing the contents, just like a sommelier! Overview of Sommelier DB Sommelier DB is an open source DB library combining SQLite and public-key searchable encryption (PKSE) . In addition to existing SQLite features, it provides functions for PKSE as below. A new SQL function to test a keyword encryption of the PKSE scheme. C and Rust functions to generate a keyword encryption and a trapdoor of the PKSE scheme. The above functions allow users to have the database (DB) server search for appropriate records in the DB without revealing their search criteria . For more detail about Sommelier DB, see here . Overview of Sommelier Drive Sommelier Drive is a remote file system developed as the first application of Sommelier DB. Its stored files and their file paths are encrypted with the public key of the legitimate user who has read permission to the file. Therefore, other users who do not have the read permission or the administrator of the server hosting the file system cannot know what files exist and where they are located . Furthermore, the legitimate users can generate trapdoors using the user's private key, allowing the server to search for the appropriate file without revealing the search criteria. Its detailed specifications are available here . Disclaimer DO NOT USE THIS LIBRARY IN PRODUCTION . At this point, this is under development. It has known and unknown bugs and security flaws. Quick Links Sommelier DB implementation Server implementation of Sommelier Drive Client implementation of Sommelier Drive Glibc client implementation of Sommelier Drive PKSE implementation written in Rust","title":"Home"},{"location":"#sommelier-db","text":"Open source DB with public-key searchable encryption: discerning encrypted data without knowing the contents, just like a sommelier!","title":"Sommelier DB"},{"location":"#overview-of-sommelier-db","text":"Sommelier DB is an open source DB library combining SQLite and public-key searchable encryption (PKSE) . In addition to existing SQLite features, it provides functions for PKSE as below. A new SQL function to test a keyword encryption of the PKSE scheme. C and Rust functions to generate a keyword encryption and a trapdoor of the PKSE scheme. The above functions allow users to have the database (DB) server search for appropriate records in the DB without revealing their search criteria . For more detail about Sommelier DB, see here .","title":"Overview of Sommelier DB"},{"location":"#overview-of-sommelier-drive","text":"Sommelier Drive is a remote file system developed as the first application of Sommelier DB. Its stored files and their file paths are encrypted with the public key of the legitimate user who has read permission to the file. Therefore, other users who do not have the read permission or the administrator of the server hosting the file system cannot know what files exist and where they are located . Furthermore, the legitimate users can generate trapdoors using the user's private key, allowing the server to search for the appropriate file without revealing the search criteria. Its detailed specifications are available here .","title":"Overview of Sommelier Drive"},{"location":"#disclaimer","text":"DO NOT USE THIS LIBRARY IN PRODUCTION . At this point, this is under development. It has known and unknown bugs and security flaws.","title":"Disclaimer"},{"location":"#quick-links","text":"Sommelier DB implementation Server implementation of Sommelier Drive Client implementation of Sommelier Drive Glibc client implementation of Sommelier Drive PKSE implementation written in Rust","title":"Quick Links"},{"location":"blog/pkse/","text":"","title":"Public key searchable encryption"},{"location":"db/apis/","text":"","title":"APIs"},{"location":"db/get_started/","text":"","title":"Get Started"},{"location":"db/how_it_works/","text":"","title":"How it works"},{"location":"db/intro/","text":"Today's databases lack security. Databases (DBs) play a significant role in today's Internet-based services. For example, online search services manage the data to be searched in a DB, which can be retrieved efficiently according to the user's request. However, the more data stored in a DB, the more serious the damage of data leakage if that DB is attacked. Notably, this is not a theoretical concern, but a real issue. In fact, it is estimated that popular Internet-based services, e.g., Yahoo, Facebook, and LinkedIn, have leaked over 100 million records [1]. From these cases, we believe that we need a solution that can protect the data confidentiality even if data is leaked from the DB . How public-key searchable encryption establishes both the convenience and security of databases. A primitive solution to the above problem is to encrypt all data in the DB so that its contents cannot be known by an adversary who attacks the DB. However, it would compromise the convenience of the DB because the server hosting the DB cannot search for the requested data. We establish both the convenience and security by encrypting the data by public-key searchable encryption (PKSE) . PKSE has the same features as standard public-key encryption schemes, e.g., RSA encryption scheme, except that the private key holder can allow a third party to test whether the encrypted data satisfies some search criteria, without revealing the data and the search criteria [2]. In more detail, a user who wishes to search for data first generates a pair of private and public keys. The public key is made available to a data provider who provides some data. The data provider encrypts the data with the user's public key and stores only the encryption on the DB server. The user then generates data corresponding to the user's search criteria, called trapdoor , and sends it to the DB server; the DB server can learn little information from the trapdoor. Since the DB server only receives the encryption and the trapdoor, it can protect the data confidentiality from an adversary who have access to all data in the DB, as well as from a malicious administrator of that server. Furthermore, the server can retrieve the encryption of the requested data using a test algorithm of the PKSE scheme. Formally, that algorithm takes as input encrypted data and a trapdoor and outputs 1 if the data satisfies the search criteria for the provided trapdoor and 0 otherwise . The server applies it to all candidate ciphertexts with the provided trapdoor and returns to the user only those for which it returns 1. In this way, the user can have the DB server search for apposite data as before. Sommelier DB: the world's first open source database based on public-key searchable encryption. Following the approach described above, we propose a new PKSE-based DB library, Sommelier DB. While the PKSE-based DB has been considered in various studies [2-5], as far as our knowledge there are no open source implementations other than ours. Sommelier DB is a fork of SQLite: it adds the following two functions: A new SQL function for the test algorithm of the PKSE scheme. C and Rust functions to generate a keyword encryption and a trapdoor of the PKSE scheme. These functions allow you to enjoy the benefits of PKSE without understanding how it works! Reference Todd, D. (2022, September). Top 10 Data Breaches of All Time, SecureWorld. https://www.secureworld.io/industry-news/top-10-data-breaches-of-all-time, (Accessed on 10/27/2022). Boneh, D., Crescenzo, G. D., Ostrovsky, R., & Persiano, G. (2004, May). Public key encryption with keyword search. In International conference on the theory and applications of cryptographic techniques (pp. 506-522). Springer, Berlin, Heidelberg. Matsuda, N., Hirano, T., Kawai, Y., Ito, T., Hattori, M., Yamanaka, T., & Nishigaki, M. (2020). Public-key Searchable Encryption with Index Generation for Shared Database. Journal of Information Processing, 28, 520-536. Wang, Z., Chen, B., Xiang, T., Zhou, L., Yan, H., & Li, J. (2021, November). Public Key Based Searchable Encryption with Fine-Grained Sender Permission Control. In International Conference on Provable Security (pp. 3-18). Springer, Cham. Prasanna, B. T., & Akki, C. B. (2015). A comparative study of homomorphic and searchable encryption schemes for cloud computing. arXiv preprint arXiv:1505.03263.","title":"Introduction"},{"location":"db/intro/#todays-databases-lack-security","text":"Databases (DBs) play a significant role in today's Internet-based services. For example, online search services manage the data to be searched in a DB, which can be retrieved efficiently according to the user's request. However, the more data stored in a DB, the more serious the damage of data leakage if that DB is attacked. Notably, this is not a theoretical concern, but a real issue. In fact, it is estimated that popular Internet-based services, e.g., Yahoo, Facebook, and LinkedIn, have leaked over 100 million records [1]. From these cases, we believe that we need a solution that can protect the data confidentiality even if data is leaked from the DB .","title":"Today's databases lack security."},{"location":"db/intro/#how-public-key-searchable-encryption-establishes-both-the-convenience-and-security-of-databases","text":"A primitive solution to the above problem is to encrypt all data in the DB so that its contents cannot be known by an adversary who attacks the DB. However, it would compromise the convenience of the DB because the server hosting the DB cannot search for the requested data. We establish both the convenience and security by encrypting the data by public-key searchable encryption (PKSE) . PKSE has the same features as standard public-key encryption schemes, e.g., RSA encryption scheme, except that the private key holder can allow a third party to test whether the encrypted data satisfies some search criteria, without revealing the data and the search criteria [2]. In more detail, a user who wishes to search for data first generates a pair of private and public keys. The public key is made available to a data provider who provides some data. The data provider encrypts the data with the user's public key and stores only the encryption on the DB server. The user then generates data corresponding to the user's search criteria, called trapdoor , and sends it to the DB server; the DB server can learn little information from the trapdoor. Since the DB server only receives the encryption and the trapdoor, it can protect the data confidentiality from an adversary who have access to all data in the DB, as well as from a malicious administrator of that server. Furthermore, the server can retrieve the encryption of the requested data using a test algorithm of the PKSE scheme. Formally, that algorithm takes as input encrypted data and a trapdoor and outputs 1 if the data satisfies the search criteria for the provided trapdoor and 0 otherwise . The server applies it to all candidate ciphertexts with the provided trapdoor and returns to the user only those for which it returns 1. In this way, the user can have the DB server search for apposite data as before.","title":"How public-key searchable encryption establishes both the convenience and security of databases."},{"location":"db/intro/#sommelier-db-the-worlds-first-open-source-database-based-on-public-key-searchable-encryption","text":"Following the approach described above, we propose a new PKSE-based DB library, Sommelier DB. While the PKSE-based DB has been considered in various studies [2-5], as far as our knowledge there are no open source implementations other than ours. Sommelier DB is a fork of SQLite: it adds the following two functions: A new SQL function for the test algorithm of the PKSE scheme. C and Rust functions to generate a keyword encryption and a trapdoor of the PKSE scheme. These functions allow you to enjoy the benefits of PKSE without understanding how it works!","title":"Sommelier DB: the world's first open source database based on public-key searchable encryption."},{"location":"db/intro/#reference","text":"Todd, D. (2022, September). Top 10 Data Breaches of All Time, SecureWorld. https://www.secureworld.io/industry-news/top-10-data-breaches-of-all-time, (Accessed on 10/27/2022). Boneh, D., Crescenzo, G. D., Ostrovsky, R., & Persiano, G. (2004, May). Public key encryption with keyword search. In International conference on the theory and applications of cryptographic techniques (pp. 506-522). Springer, Berlin, Heidelberg. Matsuda, N., Hirano, T., Kawai, Y., Ito, T., Hattori, M., Yamanaka, T., & Nishigaki, M. (2020). Public-key Searchable Encryption with Index Generation for Shared Database. Journal of Information Processing, 28, 520-536. Wang, Z., Chen, B., Xiang, T., Zhou, L., Yan, H., & Li, J. (2021, November). Public Key Based Searchable Encryption with Fine-Grained Sender Permission Control. In International Conference on Provable Security (pp. 3-18). Springer, Cham. Prasanna, B. T., & Akki, C. B. (2015). A comparative study of homomorphic and searchable encryption schemes for cloud computing. arXiv preprint arXiv:1505.03263.","title":"Reference"},{"location":"drive/get_started/","text":"","title":"Get Started"},{"location":"drive/intro/","text":"Storing files on a remote server without revealing what files exist and where they are located. As the first application of Sommelier DB, we developed a new remote file system, Sommelier Drive. Like existing services, such as Dropbox, Google Drive, and One Drive, files can be stored on a remote server, but the file contents and their file paths are all encrypted. Therefore, even a malicious administrator of that server cannot know what files exist and where they are located . In a nutshell, a data provider who creates a new file, a user who has read permission to that file, and the remote server work as below. The data provider encrypts the file contents and paths with the user's public key and stores their encryptions on the remote server. The user generates a trapdoor of the PKSE scheme with the user's private key and provides it for the remote server. The remote server returns the file contents encryption of which the corresponding file path encryption matches with the provided trapdoor. The user decrypts the returned encryption with the user's private key, which results in the file contents. The above scheme may seem almost the same as the Sommelier DB. The difference is that the user's private and public keys consist of those of PKSE and public-key encryption (PKE). The PKSE scheme is used to allow the server to search for files in the requested file path without revealing them. In addition, the PKE scheme is necessary to obtain the file contents because only with the PKSE scheme the user cannot obtain the unknown message from the ciphertext, even if the PKSE private key is available. In other words, Sommelier Drive requires the PKSE and PKE scheme to test and recover the file path and contents, respectively.","title":"Introduction"},{"location":"drive/intro/#storing-files-on-a-remote-server-without-revealing-what-files-exist-and-where-they-are-located","text":"As the first application of Sommelier DB, we developed a new remote file system, Sommelier Drive. Like existing services, such as Dropbox, Google Drive, and One Drive, files can be stored on a remote server, but the file contents and their file paths are all encrypted. Therefore, even a malicious administrator of that server cannot know what files exist and where they are located . In a nutshell, a data provider who creates a new file, a user who has read permission to that file, and the remote server work as below. The data provider encrypts the file contents and paths with the user's public key and stores their encryptions on the remote server. The user generates a trapdoor of the PKSE scheme with the user's private key and provides it for the remote server. The remote server returns the file contents encryption of which the corresponding file path encryption matches with the provided trapdoor. The user decrypts the returned encryption with the user's private key, which results in the file contents. The above scheme may seem almost the same as the Sommelier DB. The difference is that the user's private and public keys consist of those of PKSE and public-key encryption (PKE). The PKSE scheme is used to allow the server to search for files in the requested file path without revealing them. In addition, the PKE scheme is necessary to obtain the file contents because only with the PKSE scheme the user cannot obtain the unknown message from the ciphertext, even if the PKSE private key is available. In other words, Sommelier Drive requires the PKSE and PKE scheme to test and recover the file path and contents, respectively.","title":"Storing files on a remote server without revealing what files exist and where they are located."},{"location":"drive/apis/client_apis/","text":"","title":"Client APIs"},{"location":"drive/apis/server_apis/","text":"","title":"Server REST APIs"},{"location":"drive/how_it_works/client_spec/","text":"A client of Sommelier Drive can manage files on the remote server in a similar manner to Unix file systems. While our current implementation provides two types of client CLI, both of them perform each operation in the background as below. User registration A client generates new pairs of private and public keys of the PKE and PKSE schemes, dataPK and keywordPK . The client decides a name of the initial directory initDir and encrypts its file path /'initDir' with the dataPK and keywordPK , which results in the PKE and PKSE ciphertexts dataCT and keywordCT . The client posts the dataPK , keywordPK , dataCT , and keywordCT to a remote server. The remote server inserts the provided data into the User table and makes a new userId . The remote server also inserts the provided ciphertexts and userId into the Path table, where a permissionHash is derived from userId and a root file path / by the remote server. The remote server returns userId to the client. The client derives permissionHash from the returned userId and / and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested record in the Path table, which includes the id of the file path pathId . The client generates a fresh shared key sharedKey and encrypts it with dataPK , which results in the shared key encryption sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided pathId and sharedKeyCT into the Shared key table. The client constructs a bit string called contentsData as the following table: The client encrypts the contentsData with the sharedKey , which results in contentsCT . The client computes the hash value sharedKeyHash and posts contentsCT and sharedKeyHash to the remote server. The remote server inserts the provided contentsCT and sharedKeyHash into the Contents table. Field Name Bit Size Description isFile 1 1 for a file, 0 for a directory. numReadableUsers 64 A big-endian integer of the number of users with read permission. readableUserPathIds 64 * numReadableUsers A vector of pathId s corresponding to this contents. fileBytes variable A byte string of the contents of the file for a file, an empty byte string for a directory. File/Directory retrieve (touch) A client with the userId will retrieve the contents of the file located in the filePath as below. The client derives a permissionHash from the userId and the parent directory file path Parent(filePath) and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT and find the pathId whose corresponding file path is equal to the filePath . The client requests the record in the Shared key table where a value of the PathID column is equal to pathId . The remote server returns the requested record in the Shared key table. The client recovers the sharedKey from the sharedKeyCT in the returned record. The client requests the record in the Contents table where a value of the SharedKeyHash column is equal to sharedKeyHash derived from sharedKey . The remote server returns the requested record in the Contents table. The client decrypts the contentsCT in the returned record with the sharedKey , which results in the desired contentsData . Children file paths retrieve (ls) A client with the userId will retrieve the children file paths under the filePath as below. The client derives a permissionHash from the userId and the filePath and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT . These recovered file paths are the children file paths under the filePath . Descendant file paths retrieve (find) A client with the userId will retrieve the descendant file paths under the filePath as below. The client generates a trapdoor with the PKSE private key for strings with filePath as prefix and requests the records in the Path table where a value of KeywordCT column matches with the trapdoor. The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT . These recovered file paths are the descendant file paths under the filePath . File creation (touch) A client with the userId will locate a new file whose contents bytes are bytes in the filePath . The client retrieves the contentsData located in Parent(filePath) in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client generates a fresh shared key sharedKey and derives its hash sharedKeyHash . For each pathId in the readableUserPathIds , the client and the remote server performs the following process: The client requests the records in the Path table where a value of PathID column is equal to the pathId . The remote server returns the requested record in the Path table. The client retrieves the usedId from the returned record and requests the records in the User table where a value of UserID column is equal to the userId . The remote server returns the requested record in the User table. The client retrieves the dataPK and keywordPK from the returned record and encrypts the filePath with these keys, which results in the dataCT and keywordCT , respectively. The client also derives the permissionHash from the userId and the Parent(filePath) and posts the userId , permissionHash , dataCT , and keywordCT to the remote server. The remote server inserts the provided data into the Path table and returns a new pathId . The client encrypts the sharedKey with the dataPK , which results in the sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided data into the Shared key table. The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 1 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable bytes Directory creation (mkdir) A client with the userId will locate a new directory in the filePath . The client retrieves the contentsData located in Parent(filePath) in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client generates a fresh shared key sharedKey and derives its hash sharedKeyHash . For each pathId in the readableUserPathIds , the client and the remote server performs the following process: The client requests the records in the Path table where a value of PathID column is equal to the pathId . The remote server returns the requested record in the Path table. The client retrieves the usedId from the returned record and requests the records in the User table where a value of UserID column is equal to the userId . The remote server returns the requested record in the User table. The client retrieves the dataPK and keywordPK from the returned record and encrypts the filePath with these keys, which results in the dataCT and keywordCT , respectively. The client also derives the permissionHash from the userId and the Parent(filePath) and posts the userId , permissionHash , dataCT , and keywordCT to the remote server. The remote server inserts the provided data into the Path table and returns a new pathId . The client encrypts the sharedKey with the dataPK , which results in the sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided data into the Shared key table. The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 0 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable Empty bytes File Modification A client with the userId will modify a file located in the filePath with the bytes newBytes . The client retrieves the contentsData and sharedKey of the file located in filePath in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 1 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable newBytes Note that the other operations, e.g., file deletion, are not supported in the current implementation .","title":"Client Specification"},{"location":"drive/how_it_works/client_spec/#user-registration","text":"A client generates new pairs of private and public keys of the PKE and PKSE schemes, dataPK and keywordPK . The client decides a name of the initial directory initDir and encrypts its file path /'initDir' with the dataPK and keywordPK , which results in the PKE and PKSE ciphertexts dataCT and keywordCT . The client posts the dataPK , keywordPK , dataCT , and keywordCT to a remote server. The remote server inserts the provided data into the User table and makes a new userId . The remote server also inserts the provided ciphertexts and userId into the Path table, where a permissionHash is derived from userId and a root file path / by the remote server. The remote server returns userId to the client. The client derives permissionHash from the returned userId and / and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested record in the Path table, which includes the id of the file path pathId . The client generates a fresh shared key sharedKey and encrypts it with dataPK , which results in the shared key encryption sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided pathId and sharedKeyCT into the Shared key table. The client constructs a bit string called contentsData as the following table: The client encrypts the contentsData with the sharedKey , which results in contentsCT . The client computes the hash value sharedKeyHash and posts contentsCT and sharedKeyHash to the remote server. The remote server inserts the provided contentsCT and sharedKeyHash into the Contents table. Field Name Bit Size Description isFile 1 1 for a file, 0 for a directory. numReadableUsers 64 A big-endian integer of the number of users with read permission. readableUserPathIds 64 * numReadableUsers A vector of pathId s corresponding to this contents. fileBytes variable A byte string of the contents of the file for a file, an empty byte string for a directory.","title":"User registration"},{"location":"drive/how_it_works/client_spec/#filedirectory-retrieve-touch","text":"A client with the userId will retrieve the contents of the file located in the filePath as below. The client derives a permissionHash from the userId and the parent directory file path Parent(filePath) and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT and find the pathId whose corresponding file path is equal to the filePath . The client requests the record in the Shared key table where a value of the PathID column is equal to pathId . The remote server returns the requested record in the Shared key table. The client recovers the sharedKey from the sharedKeyCT in the returned record. The client requests the record in the Contents table where a value of the SharedKeyHash column is equal to sharedKeyHash derived from sharedKey . The remote server returns the requested record in the Contents table. The client decrypts the contentsCT in the returned record with the sharedKey , which results in the desired contentsData .","title":"File/Directory retrieve (touch)"},{"location":"drive/how_it_works/client_spec/#children-file-paths-retrieve-ls","text":"A client with the userId will retrieve the children file paths under the filePath as below. The client derives a permissionHash from the userId and the filePath and requests the records in the Path table where a value of PermissionHash column is equal to permissionHash . The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT . These recovered file paths are the children file paths under the filePath .","title":"Children file paths retrieve (ls)"},{"location":"drive/how_it_works/client_spec/#descendant-file-paths-retrieve-find","text":"A client with the userId will retrieve the descendant file paths under the filePath as below. The client generates a trapdoor with the PKSE private key for strings with filePath as prefix and requests the records in the Path table where a value of KeywordCT column matches with the trapdoor. The remote server returns the requested records in the Path table. For each returned record, the client decrypts its dataCT . These recovered file paths are the descendant file paths under the filePath .","title":"Descendant file paths retrieve (find)"},{"location":"drive/how_it_works/client_spec/#file-creation-touch","text":"A client with the userId will locate a new file whose contents bytes are bytes in the filePath . The client retrieves the contentsData located in Parent(filePath) in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client generates a fresh shared key sharedKey and derives its hash sharedKeyHash . For each pathId in the readableUserPathIds , the client and the remote server performs the following process: The client requests the records in the Path table where a value of PathID column is equal to the pathId . The remote server returns the requested record in the Path table. The client retrieves the usedId from the returned record and requests the records in the User table where a value of UserID column is equal to the userId . The remote server returns the requested record in the User table. The client retrieves the dataPK and keywordPK from the returned record and encrypts the filePath with these keys, which results in the dataCT and keywordCT , respectively. The client also derives the permissionHash from the userId and the Parent(filePath) and posts the userId , permissionHash , dataCT , and keywordCT to the remote server. The remote server inserts the provided data into the Path table and returns a new pathId . The client encrypts the sharedKey with the dataPK , which results in the sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided data into the Shared key table. The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 1 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable bytes","title":"File creation (touch)"},{"location":"drive/how_it_works/client_spec/#directory-creation-mkdir","text":"A client with the userId will locate a new directory in the filePath . The client retrieves the contentsData located in Parent(filePath) in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client generates a fresh shared key sharedKey and derives its hash sharedKeyHash . For each pathId in the readableUserPathIds , the client and the remote server performs the following process: The client requests the records in the Path table where a value of PathID column is equal to the pathId . The remote server returns the requested record in the Path table. The client retrieves the usedId from the returned record and requests the records in the User table where a value of UserID column is equal to the userId . The remote server returns the requested record in the User table. The client retrieves the dataPK and keywordPK from the returned record and encrypts the filePath with these keys, which results in the dataCT and keywordCT , respectively. The client also derives the permissionHash from the userId and the Parent(filePath) and posts the userId , permissionHash , dataCT , and keywordCT to the remote server. The remote server inserts the provided data into the Path table and returns a new pathId . The client encrypts the sharedKey with the dataPK , which results in the sharedKeyCT . The client posts the pathId and sharedKeyCT to the remote server. The remote server inserts the provided data into the Shared key table. The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 0 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable Empty bytes","title":"Directory creation (mkdir)"},{"location":"drive/how_it_works/client_spec/#file-modification","text":"A client with the userId will modify a file located in the filePath with the bytes newBytes . The client retrieves the contentsData and sharedKey of the file located in filePath in the same way as the file/directory retrieve process . The client parse the contentsData as (isFile, numReadableUsers, readableUserPathIds, fileBytes) . The client constructs a new contentsData as the following table and encrypts it with the sharedKey , which results in the contentsCT . The client posts the sharedKeyHash and contentsCT to the remote server. The remote server inserts the provided data into the Contents table. Field Name Bit Size Value isFile 1 1 numReadableUsers 64 numReadableUsers in Step 2. readableUserPathIds 64 * numReadableUsers readableUserPathIds in Step 2. fileBytes variable newBytes Note that the other operations, e.g., file deletion, are not supported in the current implementation .","title":"File Modification"},{"location":"drive/how_it_works/concepts/","text":"Here, we describe new concepts of Sommelier Drive and how they optimize the processes of the data provider and the remote server. Permission hash for the optimization of the ls operation. First, we introduce a permission hash. This is a hash value calculated from the ID of a legitimate user having read permission and the file path of the parent directory. The data provider, in addition to the file path encryption, stores the permission hash on the remote server. When the user wishes to perform the ls operation, that is to say, retrieve the children file paths of a directory, the user provides the remote server with the permission hash corresponding to that directory file path instead of the trapdoor. The remote server returns the file path encryptions whose corresponding permission hash is equal to the provided one. In this way, the permission hash can optimize the ls operation on the remote server. The attentive reader may think that the permission hash helps the malicious server administrator learn information about the file path. In fact, it reveals only information about sibling files and directories, i.e., those contained in the same parent directory . This is because the administrator cannot learn the actual file paths from their permission hash or encryptions but can specify the siblings by comparing the permission hashes. Shared key for the optimization of encrypting a file for multiple users. A shared key is just a secret key of symmetric key encryption (SKE), e.g., AES. It improves the efficiency when multiple users have read permission for the same file. In more detail, the file contents are encrypted with a fresh shared key, and the shared key is encrypted with each user's PKE public key. The legitimate user can obtain the file contents by (1) recovering the shared key with the PKE private key and (2) decrypting the SKE ciphertexts with the shared key. To analyze the efficiency, we compare the ciphertext size in the above scheme with that of the case where the file contents are directly encrypted with each user's PKE public key. Let \\(N, d, k\\) be the number of the legitimate users, the file contents size, and the shared key size. In the former case, the ciphertext size grows in the order \\(\\mathcal{O}(kN)\\) , whereas the order of the latter case is \\(\\mathcal{O}(dN)\\) . Therefore, our scheme is more efficient when \\(d\\) is sufficiently large.","title":"New Concepts"},{"location":"drive/how_it_works/concepts/#permission-hash-for-the-optimization-of-the-ls-operation","text":"First, we introduce a permission hash. This is a hash value calculated from the ID of a legitimate user having read permission and the file path of the parent directory. The data provider, in addition to the file path encryption, stores the permission hash on the remote server. When the user wishes to perform the ls operation, that is to say, retrieve the children file paths of a directory, the user provides the remote server with the permission hash corresponding to that directory file path instead of the trapdoor. The remote server returns the file path encryptions whose corresponding permission hash is equal to the provided one. In this way, the permission hash can optimize the ls operation on the remote server. The attentive reader may think that the permission hash helps the malicious server administrator learn information about the file path. In fact, it reveals only information about sibling files and directories, i.e., those contained in the same parent directory . This is because the administrator cannot learn the actual file paths from their permission hash or encryptions but can specify the siblings by comparing the permission hashes.","title":"Permission hash for the optimization of the ls operation."},{"location":"drive/how_it_works/concepts/#shared-key-for-the-optimization-of-encrypting-a-file-for-multiple-users","text":"A shared key is just a secret key of symmetric key encryption (SKE), e.g., AES. It improves the efficiency when multiple users have read permission for the same file. In more detail, the file contents are encrypted with a fresh shared key, and the shared key is encrypted with each user's PKE public key. The legitimate user can obtain the file contents by (1) recovering the shared key with the PKE private key and (2) decrypting the SKE ciphertexts with the shared key. To analyze the efficiency, we compare the ciphertext size in the above scheme with that of the case where the file contents are directly encrypted with each user's PKE public key. Let \\(N, d, k\\) be the number of the legitimate users, the file contents size, and the shared key size. In the former case, the ciphertext size grows in the order \\(\\mathcal{O}(kN)\\) , whereas the order of the latter case is \\(\\mathcal{O}(dN)\\) . Therefore, our scheme is more efficient when \\(d\\) is sufficiently large.","title":"Shared key for the optimization of encrypting a file for multiple users."},{"location":"drive/how_it_works/server_spec/","text":"A remote server in Sommelier Drive stores file information in Sommelier DB. That is, it creates DB tables as below. User table User table stores the id of a user and the user's PKE and PKSE public keys. They are denoted by userId , dataPK , and keywordPK , respectively, in the following description. UserID DataPK KeywordPK Int Text Text Path table Path table stores information about the file path. Each record in this table corresponds to a pair of the userId and the file path, filePath . Its columns describe the property of the file or directory located in the filePath as below. PathID UserID PermissionHash DataCT KeywordCT Int Int Text Text Text UserID: A userId of the user who has read permission to the file or directory located in the filePath . PermissionHash: A permissionHash derived from the userId and Parent(filePath) , which represents a parent directory path of the filePath . DataCT: A ciphertext of the filePath encrypted with the dataPK corresponding to the userId . KeywordCT: A ciphertext of the filePath encrypted with the keywordPK corresponding to the userId . Shared key table Shared Key table stores a pathId and a shared key encryption, sharedKeyCT . The sharedKeyCT is required to recover the file contents located in the filePath of the pathId . SharedKeyID PathID SharedKeyCT Int Int Text Contents table Contents table stores a file contents encryption, contentsCT . Each record corresponds to a sharedKeyHash , which is a hash value of the shared key. Therefore, users who hold the same shared key can access the same record. ContentsID SharedKeyHash ContentsCT Int Text Text","title":"Server Specification"},{"location":"drive/how_it_works/server_spec/#user-table","text":"User table stores the id of a user and the user's PKE and PKSE public keys. They are denoted by userId , dataPK , and keywordPK , respectively, in the following description. UserID DataPK KeywordPK Int Text Text","title":"User table"},{"location":"drive/how_it_works/server_spec/#path-table","text":"Path table stores information about the file path. Each record in this table corresponds to a pair of the userId and the file path, filePath . Its columns describe the property of the file or directory located in the filePath as below. PathID UserID PermissionHash DataCT KeywordCT Int Int Text Text Text UserID: A userId of the user who has read permission to the file or directory located in the filePath . PermissionHash: A permissionHash derived from the userId and Parent(filePath) , which represents a parent directory path of the filePath . DataCT: A ciphertext of the filePath encrypted with the dataPK corresponding to the userId . KeywordCT: A ciphertext of the filePath encrypted with the keywordPK corresponding to the userId .","title":"Path table"},{"location":"drive/how_it_works/server_spec/#shared-key-table","text":"Shared Key table stores a pathId and a shared key encryption, sharedKeyCT . The sharedKeyCT is required to recover the file contents located in the filePath of the pathId . SharedKeyID PathID SharedKeyCT Int Int Text","title":"Shared key table"},{"location":"drive/how_it_works/server_spec/#contents-table","text":"Contents table stores a file contents encryption, contentsCT . Each record corresponds to a sharedKeyHash , which is a hash value of the shared key. Therefore, users who hold the same shared key can access the same record. ContentsID SharedKeyHash ContentsCT Int Text Text","title":"Contents table"}]}